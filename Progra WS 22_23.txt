1
(b) [4 Punkte]
Gegeben sei Folgende Klasse:

Person.java

public class Person{
    private String name;

    public Person(String name) {
        this.name = name;
    }

    @Override
    public toString() {
        return name;
    }
}

Employee.java
public class Employee extends person {
    privat integer salary;

    public Employee(String name, int salary) {
        super(name);
        this.salary = salary;
    }

    @Override
    public String toString() {
        return super.toString() + ", " + salary;
    }
}}

Beim Compilieren der Klasse gibt es folgende Fehlermeldung:

Person.java:9: error: invalid methode declaration; retruns type required 
    public toString() {

Person.java:12: error: class, interface or num expected
    }}

Employee.java:2: error: cannot find Symbol
    private integer salary;

    Symbol: class integer
    location class Employee

Person.java:8: error: annotation type not applicable to this kind of declaration
    @Override

Person.java:10: error: incompatible types: unexpected return value
    retrun name:

5 errors
    

Geben sie an in welchen Zeilen die Ursachen für die Felder sind, beschreiben Sie die Fehler jeweils kurz (max. 1 Satz) und geben Sie die 
korrigierte Codezeile vollständig an, sodass der Code das tut, was bei der Programmierung wahrscheinlich vorgesehen war. Geben sie keine
Folgefehler an, die durch Korrektur eines vorherrigen Fehlers behoben werden.

Zeilennumer:Person, 9
Fehlerbeschreibung:Es fehlt das "String" vor dem toString
Korrektur:public String toString() {

Zeilennumer:Person, 12
Fehlerbeschreibung:Eine schweifende klammer zu viel in zeile 12
Korrektur:}

Zeilennumer:Employee, 2
Fehlerbeschreibung:es muss int statt integer heisen
Korrektur:public int slaray; 

Zeilennumer:
Fehlerbeschreibung:
Korrektur:


(c) [2 Punkte]
Sie haben eine Reihe von ganzzahligen Messwerten Zeilenweise in einer Textdatei /projekt/werte.txt gespeichert; ungültige Messerte sind als
-1 gespeichert. Außerdem haben Sie ein java Programm *Filter*, das zeilenweise Integer einliest und alle Integer, die nicht -1 sind, wieder
zeilenweise ausgibt.

/projekt % ls
Filter.class Filter.java werte.txt
/projekt %

Geben sie einen Befehl an, mit dem sie alle gültigen Messerte aus *werte.txt* in einer Datei *bereinigt.txt* speichern können:


Aufgabe 2
Formen sie die Kontrollstrukturen in den folgenden Codeauschnitten um, sodass sich die Semantik des Codes nicht ändert. Benutzen sie in
ihren Code jeweils nur die von der Aufgabe vorgegebene Art von Kontrollstrukturen.

(a) [2 Punkte] Formen sie die folgende for-each-Schleife in eine for-Schleife um:
Vorgabe
String[] namen = {"Alice", "Bob", "Charlie"};
int index = 0;
for (String name: namen) {
    System.out.print(index + ": " + name);
    index++
}

Ihre Lösung
String[] namen = {"Alice", "Bob", "Charlie"};
for(int index = 0; i < namen.length; i++) {
    System.out.print(i + ": " + namen[i]);
}




(b) [3 Punkte] Formen sie die folgende switch-Verzweigung in eine if-Verzweigung um:
Vorgabe
int choice = 1;
switch (choice){
    case 1;
    case 3;
        System.out.print("Feuer");
        break;
    case 2;
        System.out.print("Luft");
        break;
    default;
        System.out.print("ungültig");
}
Ihre Lösung
int choice = 1;
if(choice == 1 || choice == 3) {
    System.out.print("Feuer");
}else if (choice == 2) {
    System.out.print("Luft");
}else {
    System.out.print("ungültig")
}

Aufgabe 3

Zweirpotzenzen leeren	 2^0,2^1 etc..
Schreibe ein Java Programm Binner, das eine ganze zahl x als Konsolenarument entgegennimmt und die zweierpotenzen von 2^0 bis 2^x als ganze
Zahlen auf der Standardausgabe ausgibt. Die ausgabe soll die Form  2^5^= 32 haben (siehe Beispiel). falls kein Argument oder keine ganze 
zahl übergeben wird, soll sich das Program mit der Ausgabe err beenden.
Zur Erinnerung: Die Parse-Methoden werfen im Fehlerfall eine NumberFormatException. math.pow(a, b) berechnet a^b und gibt einen Double zu-
ück.

Beispiel-Aufrufe
% java Binner 4
2^0 = 1
2^1 = 2
2^2 = 4
2^3 = 8
2^4 = 16
% java Binner -3
% java Binner 
err
% java Binner zwei
err

Binner.java

public class Binner {
    public static void main(String[] args) {

        if(args.length == 0) {
            System.out.print("err");
            return;
        }

        int zahl;
        try{
            zahl = Integer.parseInt(args[0]);
        }catch(NumberFormatException exception) {
            System.out.print("err");
            retrun;
        }

        for(int exponent = 0; exponent <= zahl; exponent++) {
            int wert = (int) (Math.pow(2, exponent));
            System.out.print("2^" + exponent + "= " + wert);
        }

    }
}



Aufgabe 3
(a) [1 Punkt]
Gegeben sei der reguläre Ausdruck [ABCD][0-9]+. Kreuzen sie alle Strings an, die vollständig von diesem Ausdruck gematcht werden.

[]a0
[x]A4
[x]B10
[]A-4
[]G7
[]5G

(b) [1 Punkt]
Der oben ausgegebene Ausdruck ist gleichbedeutend mit:
[][A-Z0-9] + [A-Z]
[][a-z0-9] *
[][a-z0-9] * [a-z]
[][a-z0-9] [a-z0-9] * [a-z]


///// Aufgabe 4
Für eine Finanzanwendung soll ein Programm für Zinseszinsrechnung erstellt werden. Vervollständigen sie dafür die Klasse *Zinsen*:

(a) [3 Punkte]
Schreiben sie eine private, statische Methode endkapital(double k0, double p, int n), die berechnet, auf welches Endkapital KkleinerN
das Startkapital KkleinerO nach n Jahren bei einer jährlichen verzinsung von p gewachsen ist, und KkleinerN zurückgibt. Die Berechnungs-
vorschrift lautet:
KkleinerN = KkleinerO * (1 + p)^n
Zur Erinnerung: MAth.pow(a, b) berechnet a^b.

public class Zinsen {
    private static double endKapital (double KkleinerO, double p, int n) {
        return KkleinerO * Math.pow(1 + p, n) ;
    }
}

(b) [10 Punkte]
Legen sie eine main Methode an, die das Startkapital (Kommazahl größer 0) und den Zinsatz (Kommazahl größer 0) in dieser Rheienfolge Kon-
solenargumente entgegenimmt. Es soll dann jeweils das Endkapital nach 0, 1, 2 usw. Jahren ausgegeben werden, bis das Endkapital größer als
das doppelte Startkapital ist.
Wenn etwas anderes als zahlen, zu kleine zahlen oder zu wenige Zahlen angegeben werden, soll die Fehlermeldung "ungültige Eingabe" ausgege-
ben werden. Zur Erinnerung: Die Methoden zum Parsen werfen im Fehlerfall eine NumberFormatException.

Beispiele:
% java Zinsen 100 0.05
100.0
105.0
115.7625
134.0095640625
162.88946267774418
207.89281794113683
% java Zinsen 100
ungültige Eingabe
% java Zinsen 100 zwei
ungültige Eingabe

public static void main (String[] args) {
    if (args.length < 2) {
        System.out.print("ungültige Eingabe")
        return;
    }

    double KkleinerO;
    double p;
    try {
        KkleinerO = Double.parseDouble(args[0]);
        p = Double.parseDouble(args[1]);
    } catch (NumberFormatException exception) {
        System.out.print("ungültige Eingabe");
        return;
    }
    if (KkleinerO <= 0 || p <= 0) {
        System.out.print("ungültige Eingabe");
        return;
    }
    int n = 0;
    do {
        System.out.print("ungültige Eingabe");
        n++;
    } while (endKapital (KkleinerO, p, n - 1) <= KkleinerO * 2)
}

///// Aufgabe 5
Gehen sie in dieser Aufgabe davon aus, dass n € N und n >= 1 gilt.
Eine natürliche Zahl n ist eine perfekte Zahl, wenn die Summe ihrer natürlichen Teiler (n ausgeschlossen) gleich n ist. Die kleinste per-
fekte ist 6 (Telersumme 1 + 2 + 3 = 6).
Unten ist ein Programm *PerfekteZahlen* mit einer Beispielausgabe vorgegeben. Erweitern sie dieses Programm um folgende private, statische
Methoden, damit das Programm wie im Beispiel funktioniert:
(a) [4 Punkte] 
Schreiben sie eine Methode int teilersumme(int n), welche die Summe aller natürlicher Teiler von n berechnet, wobei n selbst ausgeschlossen
ist.

(b) [3 Punkte]
Schreiben sie eine Methode boolean istPerfekt(int n), die genau dann true zurückgibt, wenn n eine perfekte Zahl ist.

(c) [6 Punkte]
Schreiben sie eine Methode int[] PerfekteZahlen(int anzahl), die ein Array zurückgibt, das genau die ersten anzahl perfekten Zahlen enthält.
Falls anzahl < 0 ist, soll eine IllegalArgumentException geworfen werden.

Beispiel:
% java PerfekteZahlen
6 
true
false
6 28

PerfekteZahlen.java
public class PerfekteZahlen {
    public static void main (String[] args) {
        System.out.println(teilersumme (6));
        System.out.println(istPerfekt (6));
        System.out.println(istPerfekt (12));

        for(int zahl: perfekteZahlen(2)) {
            System.out.print(zahl + " ");
        }
    }
// Ergänzen sie hier die Methoden teilersumme, istPerfekt und perfekteZahlen.

(a)
private static int teilersumme (int n) {
    int s = 0;
    for(int = 1; i < n;i++) {
        if(n % i == 0);
        s+=i;
    }
}
return s;

(b)
private static boolean istPerfekt (int n) [
    return teilersumme (n) == n;
]

(c)
private static int[] perfekteZahlen (int anzahl) {
    if(anzahl < 0) {
        throw new IllegalArgumentException();
    }
    int[] perfekteZahlen = new int [anzahl];
    int i = 0;
    for(int n = 1; i < anzahl; n++) {
        if(istPerfekt(n)) {
            perfekteZahlen[i] = n;
            i++;
        }
    }
    return perfekteZahlen;
}

Aufgabe 6
Aus der Vorlesung kennen sie folgende Implementierung vo Insertion Sort die ein Array von Integern aufsteigend sortiert

public static void sort (int[] numbers) {
    for(int currentIndex = 0; currentIndex < numbers.length; currentIndex++) {
        int currentNumber = numbers[currentIndex];
        while(insertionPosition > 0 && numbers[insertionPosition - 1] > currentNumber){
            numbers[insertionPosition] = numbers[insertionPosition - 1];
            insertionPosition--;
        }
        numbers[insertionPosition] = currentNumber;
    }
}

Gegeben sei die folgende Klasse:
Studi.java
public class Studi {
    private final String name;
    private final double schnitt;

    public Studu(String name, double notendurschnitt) {
        this.name = name;
        this.schnitt = notendurschnitt;
    }

    public double getSchnitt() {
        return schnitt;
    }

    public double getName() {
        return name;
    }
}

(a) [6 Punkte]
Vervollständigen sie die Klassen methode nachNote, die ein Array von Studi-Objekten übergeben bekommt und ein neues Array zurückgeben soll,
in dem die selben objekte aufsteigend nach ihrer Durchschnittsnote sortiert sind (beste(also kleinste) note am anfang); die Reihenfolge der 
Objekte im übergebenden Array soll dabei von der methode nicht verändert werden, das original array und das sortierte array sollen die sel-
ben objekte im heap refferenzieren.
Falls der methode null übergeben wird, soll eine IllegalArgumentException gworfen werden. Sie dürfen davon ausgehen, dass kein Wert im über-
gebenden array null ist.

Studi.java (Fortsetung)

public static ___Studi[]____ nachNote (Studi[] studisOrig) {
    if(studiOrig == null) {
        ______throw new IllegalArgumentException()______;
    }
    __Studi[]__ studis = new Studi ___[studisOrig.length]___;
    for(int i = 0; i < studis.length; i++) {
        ____studis[i] = studisOrig[i]____;
    }
    for(int i = __1__; i < studis.length; i++) {
        ___studi: cs = studis[i]___;
        int einfPos = 1;
        while(einfPos > 0 && _____studis[einfPos - 1].schnitt > cs.schnitt)____ {
            ____Studis[einfPos] = studis[einfPos - 1]____;
            einfPos--
        }
        ____studis[einfPos] = cs ____;
    }
    ____return studis__;
}

//// Lösung:
public static void sort (Circle[] cs) {
    if(cs == null) {
        return;
    }
}
for(int ci = 0; ci < cs.length; ci++) {
    Circle cs = cs[i];
    int ip = ci;
    while(ip > 0 && cs [ip - 1] < cc.area()) {
        cs[ip] = cs[ip - 1];
    }
    cs [ip] = cc;
}

Circle.java (Fortsetung)

//// (b) [2 Punkte]
Angenommen, sie müssten häugiger 1 Millionen Kreise nach ihrer Größe sortieren. Würden sie dafür eine Sortiermethode benutzen, die In-
sertion Sort verwendet? Begründen sie ihre Antwort in 1-2 Sätzen und schlagen sie ggf. eine Alternative vor.

Lösung:
Nein, da Insertion-Sort ein langsames Sortierverfahren ist, als Alternative würde ich Mergesort nutzen.


Ergänzen sie die klasse Auflistung um folgende private, statische methoden. Sie dürfen immer davon ausgehen, dass kein Array und kein
array und kein array-wert null sind.

(b) [7 Punkte]
Studi[] zugelassen (Studi[]) gibt ein neues Studi array zurück, das nur genau die Studi-Objekte aus dem übergebenden Array entält, deren
Durchschnittsnoten kleiner als 3.0 ist.

(c) [4 Punkte]
String[] namen(Studi[]): Gibt die namen aller Studi-Objekte im übergebenden Array zurück (lässt Rheienfolge unverändert).

(d) [3 Punkte]
void ausgeben (String[]): Gibt die übergebenden Strings auf der Standardausgabe aus (lässt Rheienfolge unverändert).

(e) [4 Punkte]
Vervollständigen sie die main Methode, sodass die Namen aller bereits angelegten Studis mit einer Durchschnittsnote kleiner 3.0 ausgegeben
werden, wobei die Studis aufsteigend nach Durchschnittsnote sortiert sind. Sie müssen dabei alle in dieser Aufgabe geschriebenden Methoden
verwenden, vergessen sie nicht, dass nachnote in einer anderen klasse steht. Der Code muss auch dann korrekt funktionieren, wenn die 
Eigenschaften der drei vorgegebenden Objekte anders wären.

Auflistung.java
public class Auflistung {
    private static Studi[] zugelassen(Studi[] studis) {
        int s =0;
        For(Studi studi: studis) {
            if(studi.getSchnitt() < 3.0) {
                s++;
            }
        }
        Studi[] sts = new Studi[s];
        int i = =,
        For(Studi studi: studis) {
            if(studi.getSchnitt() < 3.0) {
                sts[i] = studi;
                i++;
            }
        }
        return sts;

    }
    private static String[] namen (Studi[] sts) {
        String n = new String[sts.length];
        for (int i= 0; i < sts.length; i++) {
            n[i] = sts[i].getName();

        }
    }
    private static void ausgeben(String[] sts) {
        for(String s: sts) {
            System.out.print(s);
        }
    }

    public static void main(String[] args) {
    Studi kim = new Studi ("Kim", 2.5);
    Studi marlin = new Studi ("marlin", 3.3);
    Studi sasha = new Studi ("sasha", 1.4);

    studi sts[] = {kim, marlin, sasha};


    ausgeben(namen(zugelassen(Studi.nachNote(sts))));
}
}


Aufgabe 7
Gegeben sei die folgende Klasse List, die eine einfach verkettete Liste implemetiert, in der Doubles gespeichert werden können:

List.java
public class List {
    private class Node {
        private double data;
        private Node next;

        private Node(double data, Node next) {
            this.data = data;
            this.next = next;
        }
    }
    private Node head;

    public List(double[]  initialValues) {
        for(int i = initialValues.length - 1; i >= 0; i--) {
            head = new Node(initialValues[i], head);
        }
    }

    public String toString() {
        // ...(nicht abgedruckt)
    }

    public void removeNegative() {
        Node current = head;
        while(current != null) {
            while(current.next != null && current.next.data < 0) {
                current.next = current.next.next;
            }
            current = current.next;
        }
    }
}

Die Methode void removeNegative() soll alle doubles aud der Liste entfernen, die kleiner als 0 sind. Die methode funktioniert aber nicht
richtig; beim folgenden Testaufruf gibt es eine unerwartete ausgabe.

Test.java
public class Test {
    public static void main(String[] args) {
        double[] listElemente = {-5.3, -2, 5, 3, -3.3, -2.2};
        List list = new List(listElemente);
        System.out.println(list); // erwartet -5.3, -2.0, 5.0, 3.0, -3.3, -2.2,
        list.removeNegative();
        System.out.println(list); // erwartet 5.0, 3.0
    }
}

% java Test 
-5.5, -2.0, 5.0, 3.0, -3.3, -2.2,
-5.3, 5.0, 3.0,

Geben sie eine korrigierte Implementierung der Methodean , alternativ können sie auch eindeutig beschreiben, wie die Fehlerhafte Implemen-
tierung korrigiert werden kann.

Ihre Lösung
public void removeNegative() {
    bei einfügen:

    while(head != null && head.data < 0) {
        head = head.next;

    }


}

 //// (a) [6 Punkte]
Vervollständigen sie die Implementierung der Methode int removeNegative(), die alle Zahlen aud der Liste entfernt, die negativ sind. Der
Rückgabewert soll angeben, wie viele Zahlen entfernt worden sind.

List.java (Fortsetung)
public int removeNegative() {
    int anzahlLoeschungen = __0___;
    while(head != null && ______head.data < 0______) {
        ____head = head.next________;
        ______anzahlLoeschungen++______;
    }
    _____Node current = head_______;
    while(__current != null__________) {
        while(current.next != null && ____current.next.data < 0________) {
            current.next = _____current.next.next_______;
            anzahlLoeschungen++;
        }
        current = ____current.next________;
    }
    ___return anzahlLoeschungen_________;
 }
}

(b) [3 Punkte]
Wie wollen in einer Datenstruktur speichern, welche Matrikelnummern sich für den Studiengang Informatik angemeldet haben; die anzahl der 
Matrikelnummern ist vorab nicht bekannt, die gespeicherte Rheienfolge ist egal. Später wollen wir sehr oft überprüfen, ob eine Matrikel-
nummer in der Datenstruktur vorhanden ist. Troy schlägt vor ein Hashset zu benutzen. Gabi meint es sollte lieber ein Array benutzt werden.


(i)
Würden sie eher den Vorschlag von Troy oder den von Gabi umsetzen? Geben sie einen nachvollziehbaren Grund in 1-3 ausformulierten Sätzen an.

Antwort:
Ich würde auf Troy hören, da das nachkucken schneller geht als im Array, ab einer bestimmten größe, und Array speichert eine Rheienfolge ab
die wird garnicht brauchen

Angenommen sie wollen eine einfach verkettete Liste in einer java Anwendung verwenden.Warum ist es sinnvoller die JDK Klasse java.util.Lin-
kedList<E> zu verwenden, anstatt eine Liste selbst zu implementieren? Geben sie einen nachvollziehbaren Grund in 1-3 ausformulierten Sätzen.

Antwort:

Es ist sinnvoller die JDK Klasse zu nutzen, weil sie schon besser getestet sind und zeit sparen.



Aufgabe 8
Gegeben sei die Klasse Tree für einen binären Suchbaum, in dem Doubles gespeichert werden können:

Tree.java
public class Tree {
    private class BinaryNode {
        private double element;
        private BinaryNode left, right;

        private BinaryNode (double element) {
            this.element = element;
        }
    }

    private BinaryNode root;

    //fügt newNumber in den Baum ein
    public void insert (double newNumber) {
        // (Implementierung nicht abgedruckt)
    }
}

Vervollständigen die die Methode int countLarge(), die die Anzahl aller Einträge im Baum zurückgibt, die größer oder gleich 100 sind;
bei einem leeren Suchbaum ist diese Summe gleich 0. Nutzen sie in ihrem code Eigenschafften eines binären Suchbaumes aus, um die Anzahl der
betrachteten Knoten minimal zu halten. Sie dürfen zusätzliche Hilfsmethoden mit minimaler Sichtbarkeit schreiben.

Tree.java (Fortsetung)
public int countLarge() {
    return countLarge(root);
}
private int countLarge(BinaryRoot root) {
    if(root == null) {
        return 0;
    }
    if(root.element >= 100) {
        return 1+ countLarge(root.left) + countLarge(root.right);
    }
    retrun countLarge(root.right);
}



Aufgabe 9
In dieser Aufgabe sollen sie Klassen und Methoden für ein Versand von Briefen und Paketen zwischen verschiedenen Standorten eines Unterneh-
mens programmieren. 

Hinweise:
-Sie dürfen alle Variablennamen frei wählen.
-Alle Instanzvariablen müssen privat sein
-Wählen sie Sinnvolle Datentypen für ihre Variable.
-Wenn kein Konstruktorverhalten vorgechrieben ist, reicht der default-Konstruktor.
-Das genaue format der Textausgaben ist ihne überlassen.
-Innerhalb dieseer Aufgaben müssen sie keine Exception abfangen. Sie müssen keine Parameter vallidieren.
-Lesen sie sich die aufgabe stelleung vor Beginn der Implementierung vollständig durch, um einen besser überblick über das Gesamtbild zu
erhalten
-Gehen sie davon aus, dass alle in dieser Aufgabe gennatnten Klassen im selben Package liegen


Gegeben ist das Interface Sendable, das eine einzele Sendung beschreibt.

Sendable.java
public interface Sendable {
    // gibt den Absende-Standort zurück
    Location senderLocation();
    // gibt den Empfang-Standort zurück
    Location receiverLocation();
    // gibt das Gewicht einer Sendung in gramm (g) zurück
    double weight;
}

                                                    Sendable
                            Location        Letter              Parcel      Delivery

(a) [8 Punkte]
Schreiben sie eine abstrakte, öffentliche Klasse Task, in welcher es eine Objektvariable gibt, die angibt, ob der task beendet ist oder 
nicht; standardmäßig sind neu erstellte TAsk nicht beendet. Über eine öffentliche Methode void finish() soll ein task auf beendet gesetzt
werden können. Mit einer öffentlichen Methode isFinished() soll abgefragt werden können, ob der Task beendet ist.
Außerdem soll es einen öffentlichen Konstruktor geben, dem der name des TAsks übergeben werden kann, und eine abstrakte, öffentliche Me-
thode getDuration(), die die Länge des TAsks (in Sekunden) zurückgibt. 
Die toString Methode solll überschrieben werden, sodass Name und länge des Tasks und ob dieser beendet ist oder nicht zurückgegeben werden.

Task.java

public abstract class Task {
    private boolean f = false;
    private String name;

    public Task (String name) {
        this.name = name;
    }

    public void finish() {
        f = true;
    }

    public boolean isFinished() {
        return f;
    }

    public abstract in getDuration() {

    }

    public String toString() {
        return name + f + getDuration();
    }
}

(b) [6 Punkte]
Implementieren sie zwei nicht abstrakte, öffentliche Klassen LongTask und ShortTask, die sinnvoll von Task erben. Jeder LongTask dauert 10
Sekunden jeder ShortTask 5 Sekunden.
Den öffentlichen Konstruktoren beider Klassen soll übergeben werden, wie die Tasks heißen; diese Information soll auf geeignete Weise Mit-
hilfe der Oberklasse gespeichert werden.

LongTask.java
public class LongTask extends Task {
    public LongTask (String name) {
        super(name);
    }

    public int getDuration() {
        return 10;
    }
}

ShortTask.java

public class ShortTask extends Task {
    public ShortTask (String name) {
        super(name);
    }

    public int getDuration() {
        return 5;
    }
}


(c) [8 Punkte]
Erstellen sie eine nicht abstrakte, öffentliche Klasse Player. Jedes Player-Objekt speichert einen namen und ein Array von beliebig vielen
Tasks, die beide dem öffentlichen Konstruktor als Parameter übergeben werden.
Schreiben sie eine öffentliche Objektmethode finishTask(int number), die den Task an der Stelle number im Array auf beendet setzt und kei-
nen Rückgabewert hat. 
Außerdem soll die toString-Methode überschrieben werden, sodass zuerst der spielername, alle nicht beendeten Tasks und danach alle beende-
ten Tasks als ein String zurückgegeben werden.

Player.java
public class Player {
    private String n;
    private Task[] ts;

    public Player (String n2, Task[] ts2) {
        n=n2;
        t=t2
    }

    public void finishTask (int nn) {
        task[nn] finish();
    }

    public String toString() {
        String out = name;
        for(Task t: ts) {
            if( !t.isFinished) {
                out t = t;
            }
        }
        for(Task t: ts) {
            if(t.isFinished) {
                out t = b;
            }
        }
        return out;
    }
}


(d) [5 Punkte] 
Ergänzen sie die Main-Methode der Klasse Game, sodass folgendes passiert:

1. Ein ShortTask mit namen "A"  und ein LongTask mit dem Namen "B" werden erstellt.
2. Ein player mit Namen "S" und den Tasks A und B wird erstellt.
3. S beendet genau einen der beiden Tasks (egal welchen).
4. Die String-Repräsentation des Player Objekts wird ausgegeben.

Game.java
public class Game {
    public static void main (String[] args) {
        Task[] ts {
            new ShortTask("A");
            new LongTask("B");
        }
        Player p = new Player ("S", ts);

        p.finishTask(A);
        System.out.println(p);
    }
}

























